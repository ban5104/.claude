#!/usr/bin/env node
// spec-check.js - Simple spec runner
const fs = require('fs');
const { spawnSync } = require('child_process');

function runCommand(cmd, timeoutSec=300) {
  console.log(`$ ${cmd}`);
  const r = spawnSync(cmd, { shell: true, stdio: 'pipe', encoding: 'utf8', timeout: timeoutSec*1000 });
  return { status: r.status, stdout: r.stdout, stderr: r.stderr };
}

function loadSpec(p) {
  return JSON.parse(fs.readFileSync(p,'utf8'));
}

function validateSpec(spec) {
  // Simple validation
  if (!spec.name || !Array.isArray(spec.acceptance) || spec.acceptance.length === 0) {
    throw new Error('Invalid spec: missing name or acceptance array');
  }
  
  const required = ['version', 'name', 'description', 'generated_by', 'generated_at', 'acceptance', 'policy'];
  for (const field of required) {
    if (!(field in spec)) {
      throw new Error(`Invalid spec: missing required field '${field}'`);
    }
  }

  for (const item of spec.acceptance) {
    if (!item.id || !item.type || !item.command || !item.description) {
      throw new Error(`Invalid acceptance item: missing required fields (id, type, command, description)`);
    }
  }
  
  console.log('✅ Spec validation passed');
}

function evaluateExpect(item, result) {
  const expect = item.expect || {};
  
  if (expect.exitCode !== undefined) {
    return result.status === (expect.exitCode || 0);
  }
  
  if (expect.status !== undefined) {
    if (result.stdout) {
      try {
        const j = JSON.parse(result.stdout);
        if (expect.bodyContains) {
          for (const k of expect.bodyContains) {
            if (!(k in j) && !JSON.stringify(j).includes(k)) return false;
          }
        }
      } catch(e) {
        for (const s of (expect.bodyContains||[])) {
          if (!result.stdout.includes(s) && !result.stderr.includes(s)) return false;
        }
      }
    }
    return true;
  }
  
  return result.status === 0;
}

async function main() {
  const specPath = process.argv[2];
  if (!specPath || !fs.existsSync(specPath)) {
    console.error('Usage: spec-check.js specs/<name>.json'); 
    process.exit(2);
  }
  
  let spec;
  try {
    spec = loadSpec(specPath);
    validateSpec(spec);
  } catch (e) {
    console.error(`❌ ${e.message}`);
    process.exit(2);
  }

  const results = [];
  let overallFail = false;

  console.log(`Running spec: ${spec.name} (${spec.description})`);
  console.log(`Generated by: ${spec.generated_by} at ${spec.generated_at}`);
  console.log('');

  for (const item of spec.acceptance) {
    console.log(`Running: ${item.id} (${item.type}) - ${item.description}`);
    const timeout = item.timeout_sec || 300;
    const cmd = item.command;
    
    if (!cmd) {
      console.log(`❌ ${item.id}: No command`);
      overallFail = true; 
      continue;
    }
    
    const res = runCommand(cmd, timeout);
    const ok = evaluateExpect(item, res);
    
    console.log(`${ok ? '✅' : '❌'} ${item.id}: ${ok ? 'PASS' : 'FAIL'}`);
    
    if (!ok) {
      overallFail = true;
      if (item.critical) {
        console.log(`💥 Critical check failed: ${item.id} - stopping`);
        break;
      }
    }
  }
  
  console.log(`\n${overallFail ? '❌ OVERALL: FAIL' : '✅ OVERALL: PASS'}`);
  process.exit(overallFail ? 1 : 0);
}

main().catch(e => { 
  console.error(`💥 Fatal error: ${e.message}`); 
  process.exit(2); 
});